---
layout:     post
title:      内部排序算法（一）
subtitle:   排序算法、插入排序
date:       2019-3-26
author:     kkkkuboy
header-img: img/post-bg-ios9-web.jpg
catalog: 	 true
tags:
    - 内部排序算法
    - 插入排序
    -
    
---

# 插入排序

### 概述

- 根据在排序过程中涉及的存储器不同，可将排序方法分为两大类：
  (1)内部排序：指的是待排序记录存放在计算机随机存储器中进行的排序过程；
  (2)外部排序：指的是待排序记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。

- 内部排序的过程是一个逐步扩大记录有序序列长度的过程
- 如果按排序过程中依据的不同原则对内部排序方法进行分类，
  则大致可分为插入排序、交换排序、选择排序、归并排序和基
  数排序等五类。
- 如果按内部排序过程中所需的工作量来区分，可分为3类：
  (1) 简单的排序方法，其时间复杂度为O (n2)；
  (2) 先进的排序方法，其时间复杂度为O (nlogn)；
  (3) 基数排序，其时间复杂度为O (dn)；
- 通常，在排序的过程中需要进行下列两种基本操作：
  (1) 比较两个关键字的大小；
  (2) 将记录从一个位置移动至另一个位置。
- 假设Ki= Kj (1≤i≤n, 1≤j≤n,i≠j)，且在排序前的序列中Ri领先于
  Rj(即i<j)。若在排序后的序列中Ri仍然领先于Rj，则称所用的排
  序方法是稳定的；反之，若可能使排序后的序列中Rj领先于Ri ，
  则称所用的排序方法是不稳定的。
- 待排序的记录序列可有下列3种存储方式：
  (1) 待排序的一组记录存放在地址连续的一组存储单元上。它类
  似于线性表的顺序存储结构，在序列种相邻的两个记录Rj和
  Rj+1(j=1,2,…,n-1)，它们的存储位置也相邻。在这种存储方式中，
  记录之间的次序关系由其存储位置决定，则实现排序必须借助移
  动记录。
  (2) 一组待排序记录存放在静态链表中，记录之间的次序关系由
  指针指示，则实现排序不需要移动记录，仅需修改指针即可，称
  为(链)表排序。
  (3) 待排序记录本身存储在一组地址连续的存储单元内，同时另
  设一个指示各个记录存储位置的地址向量，在排序过程中不移动
  记录本身，而移动地址向量中这些记录的“地址”，在排序结束
  之后再按照地址向量中的值调整记录的存储位置，称为地址排序。

#### 待排记录的数据类型：

前提：假设待排序列的一组记录使用数组存储，且记录关键字均为整数。

```C
#define MAXSIZE 20 
typedef int KeyType;//定义关键字类型为整数类型
typedef struct{
    Keytype key;//关键子项
    InfoType otherinfo;//其他数据项
    
}RedType；         //记录类型并设定关键字为整型
    typedef struct{
        RedType r[MXSIZE+1;//r[0]闲置或作为判别标志的“哨兵”单元
        int length;//顺序表长度           
    }Sqlist;
```



### 

### 1. 直接插入排序

在对记录序列R[1..n]的排序过程中，区段R[1..i-1]中的记录已按关键字非递减的顺序排列，将R[i]插入到有序序列R[1..i-1]中，使区段R[1..i]中的记录按关键字非递减顺序排列

- 实现一趟插入排序的步骤为：
  1)在R[1..i-1]中查找R[i]的插入位置，即确定j(0≤j＜i)使得
  R[1..j].key≤R[i].key＜R[j+1..i-1].key
  2)将R[j+1..i-1]中的记录后移一个位置；
  3)将R[i]插入到j+1的位置。
  为了避免在查找过程中判别循环变量是否出界，设置R[0]为监视哨，并在查找的同时进行“记录后移”

##### 直接插入排序算法

```C++
void InsertSort(SqList &L)
{//对顺序表L做直接插入排序
    for(i=2;i<=L.length;i++){//for循环将所有元素都进行排序
        if(L.r[i].key<L.r[i-1].key){//将L.r[i].key插入有序字表
            L.r[0]=L.r[i];//复制为哨兵
            L.r[i]=L.r[i-1];
            for(j=i-2;L.r[0].key<r[j].key;j--){//其实就是一直从后往前移动比较，然后找到正确的位置，因为目前的表中元素已经有序
                L.r[j+1]=L.r[j];   //有序表中的记录后移
            }
            L.r[j+1]=L.r[0];//直到插入到正确的位置
        }
    }
    
}//InsertSort
```

##### 直接插入排序时间复杂度

- 算法基本操作：
  1）关键字比较
  2）记录移动

- 与待排记录的初始状态有关：
  若正序：比较次数n-1,移动次数0
  若逆序：比较次数（n+2)(n-1)/2,移动次数(n+4)(n-1)/2

直接插入排序的时间复杂度为O(n<sup>2</sup>)



### 2. 折半插入排序

由于插入排序的基本思想是在一个有序序列中插入一个新的记录，则可以利用“折半查找”查询插入位置，由此得到的插入排序算法为“折半插入排序”

##### 折半插入排序算法

减少了比较次数

```C
void BInsertSort(SqList &L)
{//对顺序表L作折半插入排序
    for(i=2;i<L.length;i++){
        L.r[0]=L.r[i];
        low=1;
        high=i-1;
        while(low<=high){
            m=(low+high)/2;
            if(L.r[0].key<L.r[m].key){
                high=m-1;
            }
            else{
                low=m+1;
            }
        }
        for(j=i-1;j>=high+1;j--){
            L.r[j+1]=L.r[j];
        }
        L.r[high+1]=L.r[0];
    }
    
}//BInsertSort
```

##### 时间复杂度

折半插入排序只能减少排序过程中关键字比较的时间，并不能减少记录移动的时间，因此折半插入排序的时间复杂度仍为O(n<sup>2</sup>)

### 3. 2-路插入排序

2-路插入排序是在折半插入排序的基础上再改进之，减少排序过程中移动记录的次数，但为此**需要n个记录的辅助空间**。

##### 具体做法

- 另设一个和L.r同类型的数组d，首先将L.r[1]赋值给d[1]，并将d[1]看成是排好序的序列中处于中间位置的记录，然后从L.r中第2个记录起依次插入到d[1]之前或之后的有序序列中。先将待插记录的关键字和d[1]的关键字进行比较，若L.r[i].key<d[1].key，则将L.r[i]插入到d[1]之前的有序表中。反之，则将L.r[i]插入到d[1]之后的有序表中。
- 在2-路插入排序中，移动记录的次数约为n2/8。因此，2-路插入排序只能减少移动记录的次数，而不能绝对避免移动记录。并且，当L.r[1]是待排序记录中关键字最小或最大的记录时，2-路插入排序就完全失去它的优越性。



### 4. 表插入排序

表插入排序是以静态链表作待排记录序列的存储结构实现的插入排序。这个静态链表由存储记录的顺序表和附加的指针数组构成，静态链表中的指针实际上指的是数组的下标。

- 表插入排序分两步进行：首先构造一个有序链表；然后按照“附加指针”的指示将结点中的记录重新排列成一个有序序列。





### 5. 希尔排序

又称“缩小增量排序”

**基本思想**：先对待排序列进行“宏观调整”，待序列中的记录“基本有序”时再进行直接插入排序。

- 所谓“基本有序"是指，在序列中的各个关键字之前，只存在少量关键字比它大的记录。

**基本步骤**：将无序数组分割为若干个子序列，子序列不是逐段分割的，而是相隔特定的增量的子序列，对各个子序列进行插入排序；然后再选择一个更小的增量，再将数组分割为多个子序列进行排序......最后选择增量为1，即使用直接插入排序，使最终数组成为有序。
在每趟的排序过程都有一个增量，至少满足一个规则增量关系 d[1] > d[2] > d[3] >..> d[t] = 1 (t趟排序)。增量序列可以有各种取法，但需注意：应使增量序列中的值没有除1之外的公因子，并且最后一个增量值必须等于1。如dlta[]=……,9,5,3,2,1或dlta[]=……,31,15,7,3,1或dlta[]=……,40,13,4,1等。（

![1346931476_8161](C:\Users\sakura\Documents\GitHub\kukksaku.github.io\img\1346931476_8161.jpg)

![1346931514_9288](C:\Users\sakura\Documents\GitHub\kukksaku.github.io\img\1346931514_9288.jpg)

##### 希尔排序算法

```C
void ShellInsert(SqList &L,int d)
{//希尔排序的一趟排序，d为步长即增量;跟插入排序一个道理，只是可以看成同时对几个子序列进行插入排序
    for(i=d+1；i<=length;i++){//
        if(L.r[i].key<L.r[i-d].key){
            L.r[0]=L.r[i];
            for(j=i-d;j>0&&L.r[0].key<L.r[j].key;j-=d){
                L.r[j+d]=L.r[j];
                
            }
            L.r[j+d]=L.r[0];
        }
    }
    
}

void ShellSort(SqList &L,int d[],int t)
{//按增量序列d[0..t-1]对顺序表L作希尔排序
    for(k=0;k<t;k++){
        ShellSort(L,d[k]);//一趟增量为d[k]的插入排序
    }
}
```

##### 时间复杂度

希尔排序的时间复杂度和所取增量序列相关，例如已有学者证明，当增量序列为dlta[k]=2t-k-1-1(1≤k≤t≤)时，希尔排序的时间复杂度为O(n3/2)